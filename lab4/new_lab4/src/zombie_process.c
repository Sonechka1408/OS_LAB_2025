/*
 * Программа для демонстрации зомби-процессов
 * 
 * Зомби-процесс - это процесс, который завершил свое выполнение,
 * но его запись в таблице процессов еще не удалена.
 * Это происходит, когда дочерний процесс завершается раньше родительского,
 * а родительский процесс не вызвал wait() или waitpid() для получения
 * статуса завершения дочернего процесса.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(int argc, char **argv) {
  printf("=== Демонстрация зомби-процессов ===\n\n");
  
  printf("Создаю дочерний процесс...\n");
  pid_t pid = fork();
  
  if (pid < 0) {
    perror("fork failed");
    return 1;
  }
  
  if (pid == 0) {
    // Дочерний процесс
    printf("Дочерний процесс (PID: %d): Я завершаюсь через 2 секунды...\n", getpid());
    sleep(2);
    printf("Дочерний процесс (PID: %d): Завершился.\n", getpid());
    exit(0);
  } else {
    // Родительский процесс
    printf("Родительский процесс (PID: %d): Создал дочерний процесс (PID: %d)\n", getpid(), pid);
    printf("\nТеперь дочерний процесс завершится, но родитель НЕ вызовет wait().\n");
    printf("Это создаст зомби-процесс.\n");
    printf("\nДля проверки зомби-процесса откройте другой терминал и выполните:\n");
    printf("  ps aux | grep zombie_process\n");
    printf("  или\n");
    printf("  ps -eo pid,stat,comm | grep Z\n");
    printf("\nРодительский процесс будет спать 10 секунд...\n");
    
    // Родитель НЕ вызывает wait() - это создаст зомби-процесс
    sleep(10);
    
    printf("\nРодительский процесс проснулся.\n");
    printf("Если сейчас проверить процессы, зомби все еще будет существовать.\n");
    printf("\nТеперь родительский процесс вызовет wait() для очистки зомби...\n");
    
    int status;
    pid_t waited_pid = wait(&status);
    
    if (waited_pid > 0) {
      printf("Родительский процесс: Получил статус завершения дочернего процесса (PID: %d)\n", waited_pid);
      printf("Зомби-процесс теперь очищен из таблицы процессов.\n");
    }
    
    printf("\nРодительский процесс завершается.\n");
    sleep(2);
  }
  
  return 0;
}

/*
 * Объяснение зомби-процессов:
 * 
 * 1. Как появляются:
 *    - Дочерний процесс завершается (exit или return из main)
 *    - Родительский процесс НЕ вызвал wait() или waitpid() для получения статуса
 *    - Запись дочернего процесса остается в таблице процессов как "зомби"
 * 
 * 2. Чем опасны:
 *    - Зомби-процессы занимают записи в таблице процессов (PID)
 *    - Если родительский процесс создает много дочерних процессов и не ждет их завершения,
 *      это может привести к исчерпанию доступных PID в системе
 *    - Зомби-процесс не может быть "убит" сигналом SIGKILL, т.к. он уже завершен
 * 
 * 3. Как избавиться:
 *    - Родительский процесс должен вызвать wait() или waitpid() для получения статуса
 *    - После вызова wait() система удалит запись зомби-процесса из таблицы процессов
 *    - Если родительский процесс завершится, зомби-процесс будет "усыновлен" процессом init (PID 1),
 *      который периодически вызывает wait() и очищает зомби
 */


