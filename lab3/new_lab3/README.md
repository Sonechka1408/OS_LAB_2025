# Лабораторная работа №3 - Параллельный поиск минимума и максимума

Этот проект содержит решения для всех заданий лабораторной работы №3 по системному программированию.

## Структура проекта

```
new_lab3/
├── src/
│   ├── utils.h              # Структуры и функции утилит
│   ├── utils.c              # Реализация утилит
│   ├── find_min_max.h       # Заголовочный файл для поиска min/max
│   ├── find_min_max.c       # Реализация функции GetMinMax
│   ├── sequential_min_max.c # Последовательный поиск min/max
│   ├── parallel_min_max.c   # Параллельный поиск min/max
│   ├── exec_sequential.c    # Программа с exec для запуска sequential_min_max
│   └── Makefile             # Файл сборки
└── README.md                # Этот файл
```

## Задание 1: Функция GetMinMax

**Цель**: Реализовать функцию для поиска минимального и максимального элементов массива в заданном промежутке.

**Файлы**:
- `find_min_max.h` - заголовочный файл с объявлением структуры MinMax и функции
- `find_min_max.c` - реализация функции GetMinMax
- `sequential_min_max.c` - программа для тестирования функции

**Компиляция и запуск**:
```bash
cd src
make sequential_min_max
./sequential_min_max 42 1000
```

**Ожидаемый результат**:
```
min: [минимальное значение]
max: [максимальное значение]
```

## Задание 2: Параллельный поиск

**Цель**: Реализовать параллельный поиск минимума и максимума с использованием системных вызовов `fork` и `pipe`/файлов.

**Файлы**:
- `parallel_min_max.c` - основная программа параллельного поиска

**Особенности реализации**:
- Поддержка двух режимов синхронизации: через pipe и через файлы
- Разделение массива между процессами
- Измерение времени выполнения

**Компиляция и запуск**:
```bash
cd src
make parallel_min_max

# С использованием pipe (по умолчанию)
./parallel_min_max --seed 42 --array_size 1000 --pnum 4

# С использованием файлов
./parallel_min_max --seed 42 --array_size 1000 --pnum 4 --by_files
```

**Параметры**:
- `--seed` - начальное значение для генератора случайных чисел
- `--array_size` - размер массива
- `--pnum` - количество процессов
- `--by_files` - использовать файлы вместо pipe для синхронизации

## Задание 3: Makefile

**Цель**: Изучить и улучшить Makefile, добавив target `all`.

**Файлы**:
- `Makefile` - улучшенный файл сборки

**Доступные targets**:
- `all` - собрать все программы
- `sequential_min_max` - собрать последовательную программу
- `parallel_min_max` - собрать параллельную программу
- `exec_sequential` - собрать программу с exec
- `clean` - удалить все сгенерированные файлы
- `test_*` - различные тесты
- `help` - показать справку

**Использование**:
```bash
cd src
make all                    # Собрать все программы
make help                   # Показать справку
make test_all              # Запустить все тесты
```

## Задание 4: Программа с exec

**Цель**: Создать программу, которая запускает `sequential_min_max` в отдельном процессе с помощью `exec`.

**Файлы**:
- `exec_sequential.c` - программа с использованием fork и exec

**Компиляция и запуск**:
```bash
cd src
make exec_sequential
./exec_sequential 42 1000
```

## Объяснение работы программ

### Задание 1 (GetMinMax)
Функция `GetMinMax` принимает массив и границы поиска, затем проходит по указанному промежутку, находя минимальный и максимальный элементы. Использует `INT_MAX` и `INT_MIN` как начальные значения.

### Задание 2 (Параллельный поиск)
Программа демонстрирует:
- **Fork**: Создание дочерних процессов для параллельной обработки
- **Pipe**: Межпроцессное взаимодействие через каналы
- **Файлы**: Альтернативный способ передачи данных между процессами
- **Wait**: Ожидание завершения дочерних процессов
- **Разделение работы**: Массив делится между процессами поровну

### Задание 3 (Makefile)
Makefile содержит:
- **Переменные**: CC, CFLAGS для настройки компилятора
- **Зависимости**: Правильное указание зависимостей между файлами
- **Target all**: Сборка всех программ одной командой
- **Тесты**: Автоматизированные тесты для проверки работы
- **Очистка**: Удаление временных файлов

### Задание 4 (Exec)
Программа показывает:
- **Fork**: Создание дочернего процесса
- **Execv**: Замена образа процесса на другую программу
- **Wait**: Ожидание завершения дочернего процесса
- **Обработка ошибок**: Проверка возвращаемых значений

## Системные вызовы

### fork()
Создает новый процесс путем дублирования текущего процесса. Возвращает:
- `0` в дочернем процессе
- PID дочернего процесса в родительском процессе
- `-1` в случае ошибки

### pipe()
Создает канал для межпроцессного взаимодействия. Принимает массив из двух файловых дескрипторов:
- `pipefd[0]` - для чтения
- `pipefd[1]` - для записи

### execv()
Заменяет образ текущего процесса на новый. Принимает путь к исполняемому файлу и массив аргументов.

### wait()
Приостанавливает выполнение родительского процесса до завершения дочернего процесса.

## Тестирование

Для тестирования всех программ используйте:
```bash
cd src
make test_all
```

Это запустит:
1. Последовательный поиск
2. Параллельный поиск с pipe
3. Параллельный поиск с файлами
4. Программу с exec

## Требования

- GCC компилятор
- POSIX-совместимая система (Linux, macOS, WSL)
- Make утилита

## Примечания

- Программа `parallel_min_max` создает временные файлы при использовании режима `--by_files`
- Все временные файлы автоматически удаляются после завершения работы
- Время выполнения измеряется в миллисекундах
