# Лабораторная работа №5

## Структура

```
new_lab5/
├── Makefile
└── src/
    ├── mutex_demo.c        # Задание 1
    ├── factorial_mod.c     # Задание 2
    └── deadlock_demo.c     # Задание 3
```

## Подготовка

```bash
cd lab5/new_lab5
make            # соберёт все executable-файлы
```

## Задание 1 — mutex.c без и с мьютексом

Сборка:

```bash
make mutex_no_mutex
make mutex_with_mutex
```

- `mutex_no_mutex` запускает две функции, которые инкрементируют общий счётчик без синхронизации. Потоки читают и записывают `common` одновременно, поэтому итоговое значение меньше ожидаемого (race condition).
- `mutex_with_mutex` компилируется с флагом `-DUSE_MUTEX`. Макросы `LOCK/UNLOCK` превращаются в настоящие `pthread_mutex_lock / pthread_mutex_unlock`, каждый доступ к `common` защищён, и программа всегда выводит ожидаемое значение `100`.

Запуск:

```bash
./mutex_no_mutex
./mutex_with_mutex
```

## Задание 2 — Параллельный факториал по модулю

Пример:

```bash
make factorial_mod
./factorial_mod -k 10 --pnum=4 --mod=10
```

Программа разбивает диапазон `1..k` между потоками, каждый поток считает свой кусок факториала и под мьютексом домножает общий результат (значение хранится по модулю `mod`). Валидация входных аргументов встроена.

## Задание 3 — Демонстрация deadlock

```bash
make deadlock_demo
./deadlock_demo
```

Одна нить захватывает мьютексы в порядке A→B, другая — B→A. Между захватами добавлена пауза `sleep(1)`, поэтому потоки гарантированно «встревают», каждый ожидает мьютекс, который уже захвачен второй нитью. Программа зависает, демонстрируя классический deadlock. Для завершения нажмите `Ctrl+C`.

## Очистка

```bash
make clean
```

